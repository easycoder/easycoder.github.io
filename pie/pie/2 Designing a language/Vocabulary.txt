# Vocabulary

One of the most noticeable differences between human and computer languages is in the richness of their vocabularies. English has an unknown number of distinct words; estimates range from low to high hundreds of thousands. No computer language is blessed with such a rich vocabulary, though to be fair none need it. Even the most accomplished native English speakers never use the full range of words available, and as we know, computer programs function with just a few tens of words.

However, things are not quite a simple as that. A computer language may have 50 or fewer words in its vocabulary but there are usually far more distinct entities to be represented. Most modern computer languages deal with this by providing _classes_ that perform a little like native language objects. So you can create a _dog_, _cat_ or _car_ object and use its properties in the same ways as simple integers or strings. The effect of doing this isn't completely seamless; the syntax of a library _File_ object is such that if never quite behaves as if it were built-in, but it's the best most computer languages can offer.

In our own custom language we don't need to be constrained in this way. The core language can have as many special types and abilities as we are able to devise unique syntax for, only being limited by the size of the JavaScript file we have to deliver to the browser. We can go on adding as many features as we like, but eventually it will get so large it will degrade page load times to an unacceptable degree. As long as we're prepared to accept a compacted file size that's not too much more than 100k bytes or so then the load time can still be good.

Beyond that we need some kind of library mechanism to bring in special functions that are only required by particular apps. A good example is code to handle Google Maps. There's no point in bundling the necessary JS libraries unless the page actually needs to use them, so let's have a load-on-demand strategy instead. The main thing is to ensure that plug-ins of this kind add functionality in a seamless manner, where the added keywords and behaviors act as though they are a part of the core language. This allows unlimited expansion of the language capabilities.

Along with this, let's also have a mechanism for loading source scripts on demand, compiling them on the fly and releasing them when they're no longer wanted. Again, this allows the system to offer unlimited capabilities without the risk of running out of memory.

The technique proposed here enables functionality of almost any complexity to be wrapped in new language syntax and delivered on demand. This means that there is no web page or web app that cannot be built using our new language. As with maps, any large chunk of functionality that is inconvenient or clumsy to code in the syntax of our new language can be written as a self-contained JS functional unit that presents a suitable API. It can then be added to the language using a small plug-in module. The ultimate conclusion of this is a web page that contains just the word _doit_, which loads everything else as pure JavaScript, though this goes completely against the idea of making code more readable. All I'm saying is that our new language is able to play well with any other JS-based coding system. It's not a rival; it's a partner.

~pn:2 Designing a language/Environment:The coding environment:2 Designing a language/Example code:Example code~
